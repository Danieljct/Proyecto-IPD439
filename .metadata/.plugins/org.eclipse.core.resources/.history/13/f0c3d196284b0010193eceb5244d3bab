/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "dac.h"
#include "dma.h"
#include "fatfs.h"
#include "spi.h"
#include "tim.h"
#include "usart.h"
#include "gpio.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "lsm6dsl.h"
#include "stm32l4xx_nucleo_bus.h"
#include <stdio.h>
#include "arm_math.h"
#include <stdarg.h>
#include <string.h>
#include "sd_functions.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
// Estas definiciones DEBEN coincidir con tu configuración en CubeMX
#define LSM6DSL_CS_GPIO_PORT     GPIOA  // Ejemplo: Puerto A
#define LSM6DSL_CS_PIN           GPIO_PIN_15 // Ejemplo: Pin 15

// --- Constantes específicas del LSM6DSL ---
#define LSM6DSL_WHO_AM_I_REG     0x0F
#define LSM6DSL_WHO_AM_I_VAL     0x6A // Valor esperado del registro WHO_AM_I
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
// Define max FIFO size in bytes and words
#define FIFO_MAX_BYTES      4096
#define FIFO_MAX_WORDS      (FIFO_MAX_BYTES / 2)
#define ACCEL_WORDS_PER_SET 3 // Ax, Ay, Az (16 bits cada uno)
#define ACCEL_BYTES_PER_SET (ACCEL_WORDS_PER_SET * 2)
#define FIFO_MAX_SETS       (FIFO_MAX_WORDS / ACCEL_WORDS_PER_SET) // Max sets (~682)

// --- Tamaño del buffer de lectura local ---
// Leer chunks más pequeños puede ayudar a evitar bloqueos largos
// Ajusta según la memoria disponible y la velocidad de procesamiento
// Un valor entre 256 y 1024 podría ser un buen punto de partida.
#define READ_BUFFER_BYTES   4096 // Leer hasta 512 bytes (~85 sets) a la vez
#if (READ_BUFFER_BYTES > FIFO_MAX_BYTES)
#error READ_BUFFER_BYTES cannot be larger than FIFO_MAX_BYTES
#endif
#define MAX_SETS_PER_READ   (READ_BUFFER_BYTES / ACCEL_BYTES_PER_SET)
// --- Configuración Watermark ---
#define FIFO_WATERMARK_WORDS 2020 // Umbral cercano al máximo (Max FTH es 2047)
#if (FIFO_WATERMARK_WORDS > 2047)
#error FIFO_WATERMARK_WORDS cannot exceed 2047
#endif

#define fft_points 4096
#define NUM_MUESTRAS 682
//#define comments
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */
extern SPI_HandleTypeDef hspi3;
arm_rfft_fast_instance_f32 fft_instance;
uint8_t full_fifo_buffer[FIFO_MAX_BYTES];
uint8_t fifo_chunk_buffer[READ_BUFFER_BYTES];
int32_t raw_x_values[NUM_MUESTRAS]; // Sufficient size
//int32_t raw_y_values[NUM_MUESTRAS];
//int32_t raw_z_values[NUM_MUESTRAS];

// Buffers para valores CONVERTIDOS a mg (almacenados en 32 bits)
float32_t mg_x_values[NUM_MUESTRAS]; // Sufficient size
//float32_t mg_y_values[NUM_MUESTRAS];
//float32_t mg_z_values[NUM_MUESTRAS];


float32_t fft_z[fft_points];
float32_t magnitudes[fft_points/2 + 1];
float32_t fft_in[fft_points] = {0};
float32_t fft_in2[fft_points];
int counterzzz= 0;
uint16_t dac_buffer[fft_points/2 + 1];

float cached_acc_sensitivity = 0.0f; // Cache sensitivity
LSM6DSL_Object_t MotionSensor;
volatile uint32_t dataRdyIntReceived;
uint32_t time, difftime;
uint8_t lsm6dsl_init_status_spi = 0;

uint8_t fifo_was_full_last_time = 0;

uint8_t dma_tx_buffer[FIFO_MAX_BYTES + 1]; // +1 para el byte de comando
uint8_t dma_rx_buffer[FIFO_MAX_BYTES + 1]; // +1 para el byte basura recibido al inicio
volatile uint8_t fifo_int_triggered = 0;   // Flag para la interrupción INT1
volatile uint8_t spi_dma_transfer_complete = 0; // Flag para indicar fin de DMA
volatile uint8_t spi_dma_transfer_error = 0;    // Flag para error DMA/SPI
uint16_t last_dma_read_bytes = 0; // Para saber cuántos bytes procesar
FRESULT generate_sine_to_csv(const char* filename, double amplitude, double frequency, double duration, int num_points);
FRESULT write_magnitudes_to_sd(const char* filename, float32_t* magnitudes_array, uint16_t num_magnitudes); // Added prototype for new function
static uint8_t new_fft_data_complete = 0; // Flag to indicate a full set of FFT data is ready for writing
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */
static void MEMS_Init_SPI_FIFO_Int(void);
static void Start_FIFO_Read_DMA(void);
static void Process_FIFO_Data_DMA(uint16_t bytes_received_incl_dummy);
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
int firststart = 1;
int finish = 0; int startfft = 0; int movefft = 0;
void HAL_DMA_Callback(DMA_HandleTypeDef *hdma){
	printf("(%.1f) DMA Callback\n",(TIM2->CNT)/80.0);
	if(hdma -> Instance == DMA1_Channel1){
		difftime = TIM2->CNT - time;
		if(movefft){
			movefft = 0;
			HAL_DMA_Start_IT(&hdma_memtomem_dma1_channel1, fft_in, fft_in2, fft_points);
		}
		else{
			finish = 1;
			HAL_TIM_Base_Start_IT(&htim4);
		}

	}
}

FATFS fs;  // file system
FIL fil; // File
FILINFO fno;
FRESULT fresult;  // result
UINT br, bw;  // File read/write count

/**** capacity related *****/
FATFS *pfs;
DWORD fre_clust;
uint32_t total, free_space;

#define BUFFER_SIZE 128
char buffer[BUFFER_SIZE];  // to store strings..

int i=0;

int bufsize (char *buf)
{
	int i=0;
	while (*buf++ != '\0') i++;
	return i;
}

void clear_buffer (void)
{
	for (int i=0; i<BUFFER_SIZE; i++) buffer[i] = '\0';
}

void send_uart (char *string)
{
	uint8_t len = strlen (string);
	HAL_UART_Transmit(&huart2, (uint8_t *) string, len, HAL_MAX_DELAY);  // transmit in blocking mode
}

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

    // Initialize the FFT instance (this was commented out, but is essential for FFT operations)
	arm_status status_fft = arm_rfft_fast_init_f32(&fft_instance, fft_points);
	if (status_fft != ARM_MATH_SUCCESS) {
		printf("Error: Failed to initialize RFFT instance.\r\n");
		Error_Handler();
	}
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_DMA_Init();
  MX_USART2_UART_Init();
  MX_DAC1_Init();
  MX_SPI2_Init();
  MX_FATFS_Init();
  MX_TIM2_Init();
  MX_TIM5_Init();
  MX_TIM4_Init();
  MX_TIM6_Init();
  /* USER CODE BEGIN 2 */

 HAL_TIM_Base_Start(&htim2);
  printf("Starting\r\n");

   FATFS MiFatFs; // Objeto del sistema de archivos
      char MiSdPath[4]; // Ruta ej: "0:/"

      // Attempt to mount the SD card
      FRESULT mount_res = f_mount(&MiFatFs, MiSdPath, 1);
      if (mount_res == FR_OK) {
   	   printf("SD montada. Procediendo a generar CSV...\r\n");

          // Check free space after mounting to diagnose card health/write-protect
          DWORD free_clusters;
          FATFS* filesystem_obj;
          FRESULT getfree_res = f_getfree(MiSdPath, &free_clusters, &filesystem_obj);
          if (getfree_res == FR_OK) {
              total = (filesystem_obj->n_fatent - 2) * filesystem_obj->csize / 2; // Total KB
              free_space = free_clusters * filesystem_obj->csize / 2; // Free KB
              printf("SD Card: Total space: %luKB, Free space: %luKB\r\n", total, free_space);
          } else {
              printf("Error al obtener espacio libre de la SD Card. Codigo FatFs: %d\r\n", getfree_res);
              // This often indicates a deeper issue than just a file not found, even if mount succeeded.
          }

          // --- NEW: Try creating a subdirectory first ---
          const char* data_dir = "0:/DATA";
          FRESULT mkdir_res = f_mkdir(data_dir);
          if (mkdir_res == FR_OK) {
              printf("Directorio '%s' creado exitosamente o ya existe.\r\n", data_dir);
          } else if (mkdir_res == FR_EXIST) {
              printf("Directorio '%s' ya existe. No es necesario crearlo.\r\n", data_dir);
          } else {
              printf("Error al crear directorio '%s'. Codigo FatFs: %d\r\n", data_dir, mkdir_res);
              // If directory creation fails, it's unlikely file creation will succeed.
              // We could exit here or try anyway for more debug info.
          }

          // Call the function to generate the file, now inside the DATA directory
          FRESULT res_sine = generate_sine_to_csv(
                              "0:/DATA/sin1.csv", // File name on SD, now in DATA folder
                              5.0,                // Amplitude = 5.0
                              2.0,                // Frequency = 2 Hz (2 cycles per second)
                              3.0,                // Duration = 3 seconds
                              4                 // Number of points = 150 (will generate 150 points in 3 sec)
                          );
          if (res_sine == FR_OK) {
       	   printf("Archivo CSV 'sin1.csv' generado con éxito en /DATA.\r\n");
          } else {
       	   printf("Fallo al generar el archivo CSV 'sin1.csv'. Codigo FatFs: %d\r\n", res_sine); // Print detailed error
          }

          // Also update the magnitudes file path
          // Note: The write_magnitudes_to_sd call is in HAL_TIM_PeriodElapsedCallback (TIM4),
          // so ensure that the filename there also points to "0:/DATA/magnitudes.csv"
          printf("La escritura de magnitudes intentará usar '0:/DATA/magnitudes.csv'.\r\n");


          // Optional: unmount the drive if no longer needed
          f_mount(NULL, MiSdPath, 0);

      } else {
   	   printf("Error al montar la SD Card. Codigo FatFs: %d\r\n", mount_res); // Print detailed error for mount
      }

      printf("---- LSM6DSL FIFO Interrupt + DMA SPI (Accel Z @ 6.66kHz) ----\r\n");
       MEMS_Init_SPI_FIFO_Int(); // Call correct initialization
      HAL_TIM_Base_Start_IT(&htim5);
         if(HAL_TIM_Base_Start(&htim6) != HAL_OK)
       {
           printf("Error iniciando TIM6!\r\n");
           Error_Handler();
       }

      if(HAL_DAC_Start_DMA(&hdac1, DAC_CHANNEL_1, (uint32_t*)dac_buffer, fft_points/2 + 1, DAC_ALIGN_12B_R) != HAL_OK)
      {
          printf("Error iniciando DAC1_CH1 DMA!\r\n");
          Error_Handler();
      }

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
	 /* if (fifo_int_triggered)
	      {
	          fifo_int_triggered = 0; // Reset flag for INT1
	          // Only start DMA if no other transfer or error is pending
	          if (!spi_dma_transfer_complete && !spi_dma_transfer_error) {
	               Start_FIFO_Read_DMA(); // Start DMA read
	          } else {
	               printf("WARN: FIFO Int but DMA still active or error.\n");
	          }

	      }
*/
	      // Check if a DMA transfer finished (optional if you process in callback)
	     /* if (spi_dma_transfer_complete) {

#ifdef comments
	          printf("DMA Completed OK.\n");
#endif



	          // Process read data in dma_rx_buffer
	          //Process_FIFO_Data_DMA(last_dma_read_bytes + 1); // +1 for dummy byte

	          // Reset FIFO here (safer outside the callback)
#ifdef comments
	          printf("Resetting FIFO post-DMA...\r\n");
#endif

	      }
*/

	  	  counterzzz++;

	      // Yield time
	      HAL_Delay(1);
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 1;
  RCC_OscInitStruct.PLL.PLLN = 10;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */



int32_t SPI_Send(void *ignored_handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
    uint16_t transfer_size = 1 + Length;
    int32_t ret = BSP_ERROR_NONE; // 0
    // Local buffer for complete transmission
    uint8_t tx_buffer[transfer_size];
    // Prepare write command (MSB=0 for write)
    tx_buffer[0] = 0x7F & Reg; // Set bit 7 to 0
    memcpy(&tx_buffer[1], pData, Length);

    GPIOA->BSRR = GPIO_PIN_1 << 16; // Set pin to low (CS low)
    if (HAL_SPI_Transmit(&hspi3, tx_buffer, transfer_size, BUS_SPI3_POLL_TIMEOUT*10) != HAL_OK)
    {
         printf("BSP_SPI3_Send: HAL_SPI_Transmit failed!\r\n");
         ret = BSP_ERROR_UNKNOWN_FAILURE; // Or a more specific error code
    }
    GPIOA->BSRR = GPIO_PIN_1; // Set pin to high (CS high)
    return ret;
}

int32_t SPI_Recv(void *handle, uint8_t reg, uint8_t *data, uint16_t len)
{

    uint16_t transfer_size = 1 + len;
    uint8_t tx_buffer[transfer_size];
    uint8_t rx_buffer[transfer_size];

    tx_buffer[0] = 0x80 | reg; // Prepare read command (MSB=1 for read)

    // Fill rest of Tx with dummy bytes (0x00 or 0xFF)
    for (uint16_t i = 1; i < transfer_size; i++) {
        tx_buffer[i] = 0x00; // Or 0xFF
    }

    time = TIM2->CNT;
    GPIOA->BSRR = GPIO_PIN_1<< 16; // Set pin to low (CS low)
    HAL_StatusTypeDef status = HAL_SPI_TransmitReceive(&hspi3, tx_buffer, rx_buffer, transfer_size, HAL_MAX_DELAY); // Use an appropriate timeout
    GPIOA->BSRR = GPIO_PIN_1 ; // Set pin to high (CS high)

   difftime = TIM2->CNT - time;
    if (status == HAL_OK) {
        memcpy(data, &rx_buffer[1], len); // Copy received data, excluding the first dummy byte
        return 0; // Success (LSM6DSL_OK)
    } else {
        // HAL communication error
        printf("BSP_SPI3_Recv: HAL_SPI_TransmitReceive failed with status: %d\r\n", status);
        // Return an error code. You could map HAL_ERROR, HAL_TIMEOUT etc. to specific errors.
        if (status == HAL_TIMEOUT) {
             return -2; // Example for timeout
        } else {
             return -1; // Generic error (LSM6DSL_ERROR)
        }
    }
}

static void MEMS_Init_SPI_FIFO_Int(void)
{
    LSM6DSL_IO_t io_ctx;
    uint8_t id;
    int32_t status;
    lsm6dsl_int1_route_t int1_route; // To configure INT1
    float sens_a;

    printf("Configuring I/O SPI interface...\r\n");
    // Configure io_ctx (SPI_4WIRES, SPI_Send/Recv, etc.)
    io_ctx.Init = BSP_SPI3_Init;
    io_ctx.DeInit = BSP_SPI3_DeInit;
    io_ctx.BusType = LSM6DSL_SPI_4WIRES_BUS;
    io_ctx.Address = 0;
    io_ctx.WriteReg = SPI_Send;
    io_ctx.ReadReg = SPI_Recv;
    io_ctx.GetTick = BSP_GetTick;

    status = LSM6DSL_RegisterBusIO(&MotionSensor, &io_ctx);
    if (status != LSM6DSL_OK) { printf("E:RegBusIO(%ld)\r\n", status); Error_Handler(); return; }

    printf("Reading WHO_AM_I...\r\n");
    status = LSM6DSL_ReadID(&MotionSensor, &id);
    if (status != LSM6DSL_OK) { printf("E:ReadID(%ld)\r\n", status); Error_Handler(); return; }
    printf("WHO_AM_I = 0x%02X\r\n", id);
    if (id != LSM6DSL_ID) { printf("E:WrongID\r\n"); Error_Handler(); return; }

    printf("LSM6DSL detected! Initializing...\r\n");
    status = LSM6DSL_Init(&MotionSensor);
    if (status != LSM6DSL_OK) { printf("E:Init(%ld)\r\n", status); Error_Handler(); return; }

    // --- Configure Sensors ---
    printf("Configuring Accel at 6.66 kHz, Gyro OFF...\r\n");
    status = LSM6DSL_ACC_SetOutputDataRate(&MotionSensor, 6660.0f);
    if (status != LSM6DSL_OK) { printf("E:AccODR(%ld)\r\r\n", status); Error_Handler(); return; }
    status = LSM6DSL_ACC_SetFullScale(&MotionSensor, 4);
    if (status != LSM6DSL_OK) { printf("E:AccFS(%ld)\r\r\n", status); Error_Handler(); return; }
    status = LSM6DSL_GYRO_Disable(&MotionSensor);
    if (status != LSM6DSL_OK) { printf("E:GyroDis(%ld)\r\r\n", status); Error_Handler(); return; }
    if (LSM6DSL_ACC_GetSensitivity(&MotionSensor, &cached_acc_sensitivity) != LSM6DSL_OK) {
         printf("E:GetSens\r\n"); Error_Handler(); return;
    }
    printf("Accel Sensitivity: %.3f mg/LSB\r\n", cached_acc_sensitivity);

    // --- Configure FIFO ---
    printf("Configuring FIFO (6.66kHz, Accel Only, Stream Mode, WTM=%d, StopOnWTM=0)...\r\n", FIFO_WATERMARK_WORDS);
    status = LSM6DSL_FIFO_Set_ODR_Value(&MotionSensor, 6660.0f);
    if (status != LSM6DSL_OK) { printf("E:FifoODR(%ld)\r\r\n", status); Error_Handler(); return; }
    status = LSM6DSL_FIFO_ACC_Set_Decimation(&MotionSensor, LSM6DSL_FIFO_XL_NO_DEC);
    if (status != LSM6DSL_OK) { printf("E:FifoAccDec(%ld)\r\r\n", status); Error_Handler(); return; }
    status = LSM6DSL_FIFO_GYRO_Set_Decimation(&MotionSensor, LSM6DSL_FIFO_GY_DISABLE);
    if (status != LSM6DSL_OK) { printf("E:FifoGyroDec(%ld)\r\r\n", status); Error_Handler(); return; }

    // Configure Watermark Level
    status = LSM6DSL_FIFO_Set_Watermark_Level(&MotionSensor, FIFO_WATERMARK_WORDS);
    if (status != LSM6DSL_OK) { printf("E:SetWTM(%ld)\r\r\n", status); Error_Handler(); return; }

    // Ensure "Stop on Watermark" is DISABLED (for true Stream mode)
    status = lsm6dsl_fifo_stop_on_wtm_set(&(MotionSensor.Ctx), 0); // 0 = Disabled
     if (status != LSM6DSL_OK) { printf("E:StopOnWTM(%ld)\r\r\n", status); Error_Handler(); return; }

    // --- Configure INT1 Interrupt for Watermark ---
    // Ensure the EXTI pin (LSM6DSL_INT1_PIN) is configured in CubeMX
    printf("Configuring INT1 for FIFO Watermark...\r\n");
    status = lsm6dsl_pin_int1_route_get(&(MotionSensor.Ctx), &int1_route);
     if (status != LSM6DSL_OK) { printf("E:GetInt1Route(%ld)\r\r\n", status); Error_Handler(); return; }
    // Enable ONLY watermark interrupt on INT1
    int1_route.int1_fth = 1;
    int1_route.int1_fifo_ovr = 0; // Disable OVF on INT1 (we check by status)
    int1_route.int1_full_flag = 0;
    int1_route.int1_drdy_xl = 0; // Disable DRDY if not used
    //... disable other sources if necessary ...
    status = lsm6dsl_pin_int1_route_set(&(MotionSensor.Ctx), int1_route);
    if (status != LSM6DSL_OK) { printf("E:SetInt1Route(%ld)\r\r\n", status); Error_Handler(); return; }
    // You can configure Latch/Pulse, Active High/Low here if needed
    // lsm6dsl_int_notification_set(...)
    // lsm6dsl_pin_polarity_set(...)

    // --- Start operation ---
    // Set to Stream mode (this should also clear the FIFO)
    status = LSM6DSL_FIFO_Set_Mode(&MotionSensor, LSM6DSL_STREAM_MODE);
    if (status != LSM6DSL_OK) { printf("E:FifoSetMode(%ld)\r\r\n", status); Error_Handler(); return; }

    printf("Activating Accelerometer...\r\n");
    status = LSM6DSL_ACC_Enable(&MotionSensor);
    if (status != LSM6DSL_OK) { printf("E:AccEnable(%ld)\r\r\n", status); Error_Handler(); return; }

    printf("LSM6DSL configured for Int. Watermark (%d words) at 6.66kHz (Accel Only, Stream Mode).\r\n", FIFO_WATERMARK_WORDS);
    printf("Waiting for interrupts on pin %d...\n", LSM6DSL_INT1_PIN);

    lsm6dsl_init_status_spi = 1;
    fifo_int_triggered = 0; // Ensure flag is clean
    spi_dma_transfer_complete = 0; // Ensure flags are clean
    spi_dma_transfer_error = 0;
}

/**
  * @brief Starts FIFO read using DMA. Called from main loop.
  */

uint16_t num_words_available = 0;
uint16_t bytes_to_read = 0;
int32_t status;
static void Start_FIFO_Read_DMA(void)
{
    if (!lsm6dsl_init_status_spi) return;

    num_words_available = 0;
    bytes_to_read = 0;

    // Read FIFO level
    status = LSM6DSL_FIFO_Get_Num_Samples(&MotionSensor, &num_words_available);
    //if (status != LSM6DSL_OK) { printf("E:StartRead_GetSamples(%ld)\r\r\n", status); return; }

    // Determine how many bytes to read (do not exceed buffer or FIFO max)
    bytes_to_read = num_words_available * 2;
    if (bytes_to_read == 0) return; // Nothing to read
    if (bytes_to_read > FIFO_MAX_BYTES) {
        printf("WARN: FIFO level %u > Buffer! Clipping to %d bytes.\r\n", num_words_available, FIFO_MAX_BYTES);
        bytes_to_read = FIFO_MAX_BYTES;
    }

    printf("INT DMA! Reading %u words (%u bytes)...\r\n", num_words_available, bytes_to_read);
    last_dma_read_bytes = bytes_to_read; // Save for the callback

    // TX buffer: Read command + Dummies
    dma_tx_buffer[0] = LSM6DSL_FIFO_DATA_OUT_L | 0x80; // Command Read from FIFO_DATA_OUT_L
    memset(&dma_tx_buffer[1], 0x00, bytes_to_read); // Dummies

    spi_dma_transfer_complete = 0; // Mark as not complete
    spi_dma_transfer_error = 0;    // Clear error flag

    time = TIM2->CNT;

    GPIOA->BSRR = GPIO_PIN_1<< 16;
    HAL_StatusTypeDef dma_status = HAL_SPI_TransmitReceive_DMA(&hspi3,
                                                               dma_tx_buffer,
                                                               dma_rx_buffer, // Read into DMA RX buffer
                                                               bytes_to_read + 1); // Total size = Command + Data

    difftime = TIM2->CNT - time;

    if (dma_status != HAL_OK) {
        GPIOA->BSRR = GPIO_PIN_1 ; // CS High on error
        printf("E:HAL_SPI_TransmitReceive_DMA (%d)\r\n", dma_status);
        spi_dma_transfer_error = 1; // Mark error
        // Reset FIFO?
        lsm6dsl_fifo_mode_set(&(MotionSensor.Ctx), LSM6DSL_BYPASS_MODE); HAL_Delay(1);
        lsm6dsl_fifo_mode_set(&(MotionSensor.Ctx), LSM6DSL_STREAM_MODE);
    } else {
        // DMA started correctly
    	time = TIM2->CNT;
        uint32_t time_us = difftime / 80;
#ifdef comments
        printf("DMA started (%lu ticks = ~%lu us)\r\n", difftime, time_us);
#endif
        // CS will be set HIGH in the completion or error callback
    }
   // HAL_TIM_Base_Start_IT(&htim5);
}

const int INITIAL_BUFFER_OFFSET = 1;
/**
  * @brief Processes data received via DMA from FIFO (Z-axis only).
  */
static void Process_FIFO_Data_DMA(uint16_t bytes_received_incl_dummy)
{
    uint32_t time_us = difftime / 80;
#ifdef comments
    printf("DMA Completed in (%lu ticks = ~%lu us)\r\r\n", time_us);
#endif

    if (cached_acc_sensitivity == 0.0f || bytes_received_incl_dummy <= 1) return;

    uint16_t bytes_accel_data = bytes_received_incl_dummy - 1; // Actual data (without the first dummy byte)
    uint16_t sets_leidos = bytes_accel_data / ACCEL_BYTES_PER_SET;
    uint8_t* data_start_ptr = dma_rx_buffer + INITIAL_BUFFER_OFFSET;
#ifdef comments
    printf("--- Processing %u DMA sets ---\r\n", sets_leidos);
#endif
    for (int i = 0; i < sets_leidos; i++) {
            // Calculate the pointer to the start of the current sample's 6 bytes
            uint8_t* pSampleBytes = data_start_ptr + (i * ACCEL_BYTES_PER_SET);

            // --- Extract Raw 16-bit Values and Store in 32-bit Buffers ---
            // X (LSB in pSampleBytes[0], MSB in pSampleBytes[1])
            raw_x_values[i] = (int16_t)(((uint16_t)pSampleBytes[1] << 8) | pSampleBytes[0]);

            // Y (LSB in pSampleBytes[2], MSB in pSampleBytes[3])
            //raw_y_values[i] = (int16_t)(((uint16_t)pSampleBytes[3] << 8) | pSampleBytes[2]);

            // Z (LSB in pSampleBytes[4], MSB in pSampleBytes[5])
            //raw_z_values[i] = (int16_t)(((uint16_t)pSampleBytes[5] << 8) | pSampleBytes[4]);

            // --- Convert Raw Values to mg and Store in 32-bit Buffers ---
            mg_x_values[i] = (float32_t)((float)raw_x_values[i] * cached_acc_sensitivity);
         //   mg_y_values[i] = (float32_t)((float)raw_y_values[i] * cached_acc_sensitivity);
         //   mg_z_values[i] = (float32_t)((float)raw_z_values[i] * cached_acc_sensitivity);


            // --- Optional: Print for first/last few samples (like in user's snippet) ---
          //  if (i < 5 || i >= (sets_leidos - 5)) {
          //      printf(" Set[%3u]: Ax = %f mg, Ay = %5f mg, Az = %5f mg\r\r\n",
          //             i, mg_x_values[i], mg_y_values[i], mg_z_values[i]);
          //  }

        }
    static int current_accumulated_sets = 0; // Renamed for clarity
    finish = 0;

    hdma_memtomem_dma1_channel1.XferCpltCallback = &HAL_DMA_Callback;
    startfft = 1;
    movefft = 1;
    // Copy into fft_in at the correct offset
    HAL_DMA_Start_IT(&hdma_memtomem_dma1_channel1, mg_x_values, &fft_in[current_accumulated_sets], sets_leidos);
    current_accumulated_sets += sets_leidos;

    // Check if a full set of data for FFT has been accumulated
    if (current_accumulated_sets >= fft_points) { // Use fft_points (4096) for consistency with FFT
        new_fft_data_complete = 1; // Flag that a full FFT buffer is ready
        current_accumulated_sets = 0; // Reset for next accumulation cycle
    }


    /*float32_t fft_in[fft_points] = {0};
    memcpy(fft_in, mg_z_values, sizeof(mg_z_values)/2);
#ifdef comments
    printf("--- End DMA Processing ---\r\r\n");
#endif
    arm_rfft_fast_f32(&fft_instance,fft_in,fft_z, 0);
    // Calculate DC and Nyquist separately
    magnitudes[0] = fabsf(fft_z[0]);
    #if (fft_points % 2 == 0) // If N is even, there is a Nyquist component
    	magnitudes[fft_points/2] = fabsf(fft_z[1]);
    #endif
    arm_cmplx_mag_f32(&fft_z[2], &magnitudes[1], (fft_points - 2) / 2);

    printf("DMA x:");
    for (int i = 0; i < fft_points/2+1; i++) {
        printf("%.0f ", magnitudes[i]);
    }*/



}
extern uint8_t spiDmaTransferComplete;

void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
{
    if(hspi->Instance == SPI3) // Check if it's the SPI3 interrupt
    {
    	printf("(%.1f) SPI3 Callback\n",(TIM2->CNT)/80.0);
    	difftime = TIM2->CNT - time;
        GPIOA->BSRR = GPIO_PIN_1 ; // <<< CS HIGH here
        lsm6dsl_fifo_mode_set(&(MotionSensor.Ctx), LSM6DSL_BYPASS_MODE);
		HAL_TIM_Base_Start_IT(&htim4);
    }
    if (hspi->Instance == SPI2){
    	spiDmaTransferComplete = 1;
    }
}

/**
  * @brief SPI error callback (used by DMA and other modes).
  */
void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
{
     if(hspi->Instance == SPI3)
     {
    	GPIOA->BSRR = GPIO_PIN_1 ; // <<< CS HIGH on error too
        printf("!!! HAL_SPI_ErrorCallback - Error Code: 0x%lX !!!\r\r\n", hspi->ErrorCode);
        spi_dma_transfer_error = 1; // Set error flag
        lsm6dsl_fifo_mode_set(&(MotionSensor.Ctx), LSM6DSL_BYPASS_MODE);
        spi_dma_transfer_complete = 0; // Not completed correctly

        // Try to reset FIFO
        // lsm6dsl_fifo_mode_set(&(MotionSensor.Ctx), LSM6DSL_BYPASS_MODE);
        // HAL_Delay(1); // CAUTION
        // lsm6dsl_fifo_mode_set(&(MotionSensor.Ctx), LSM6DSL_STREAM_MODE);

        // You might want to call Error_Handler() or try to recover
     }
}


/**
  * @brief EXTI Line Detection Callback.
  * @param GPIO_Pin Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
  // Ensure the pin matches the one connected to sensor INT1
  if (GPIO_Pin == GPIO_PIN_0) {
    //fifo_int_triggered = 1; // Set the flag for the main loop
    // DO NOT perform SPI/I2C reads here within the interrupt.
  }
}

void HAL_DAC_ConvCpltCallbackCh1(DAC_HandleTypeDef* hdac)
{
    // This callback is called when the DMA finishes traversing the ENTIRE buffer
    // (useful if you do NOT use Circular mode, or for synchronization)
    // In circular mode, it is called every time it completes a loop of the buffer.
    // You could use it to switch buffers (ping-pong) or adjust something.
    // Example: blink an LED
    HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim){
  static int count = 0;
  if (htim->Instance == TIM5) {
	  printf("(%.1f) TIM5 Callback\n",(TIM2->CNT)/80.0);
#ifdef comments
	  printf("TIM5 Period: %.1f us\r\r\n", (TIM2->CNT-count)/80.0f);
#endif
   // fifo_int_triggered = 1; // Set the flag for the main loop
    HAL_TIM_Base_Stop_IT(&htim5); // Stop the timer
    Start_FIFO_Read_DMA();
    count = TIM2->CNT;
  }
  if(htim->Instance == TIM4){
	  printf("(%.1f) TIM4 Callback\n",(TIM2->CNT)/80.0);
	  HAL_TIM_Base_Stop_IT(&htim4);

      if(startfft && finish){
  		  printf("counterzzz: %d\n",counterzzz);
  		  counterzzz = 0;
        int STARTtiempofft = TIM2->CNT;
        arm_rfft_fast_f32(&fft_instance,fft_in2,fft_z, 0);
        // Calculate DC and Nyquist separately
        magnitudes[0] = fabsf(fft_z[0]);
        #if (fft_points % 2 == 0) // If N is even, there is a Nyquist component
          magnitudes[fft_points/2] = fabsf(fft_z[1]);
        #endif
        arm_cmplx_mag_f32(&fft_z[2], &magnitudes[1], (fft_points - 2) / 2);
        int tiempofft =  TIM2->CNT -STARTtiempofft;
        printf("FFT time: %.4f ms\n", tiempofft/80000.0);
        const char* header = "DMA x:";
        HAL_UART_Transmit(&huart2, (uint8_t*)header, strlen(header), HAL_MAX_DELAY);

        // Send binary data
        HAL_UART_Transmit(&huart2, (uint8_t*)magnitudes, (fft_points/2+1) * sizeof(float32_t), HAL_MAX_DELAY);

        // Send footer
        const char* footer = "END.";
        HAL_UART_Transmit(&huart2, (uint8_t*)footer, strlen(footer), HAL_MAX_DELAY);
        //for (int k = 0; k<fft_points; k++) fft_in[k]=0;
        float magintudmax;
        for(int i = 100; i < fft_points/2 + 1; i++) {
            if(i == 0) {
                magintudmax = magnitudes[i];
            }
            else if(magnitudes[i] > magintudmax) {
                magintudmax = magnitudes[i];
            }
        }

        for(int i = 0; i < fft_points/2 + 1; i++) {
            dac_buffer[i] = (uint16_t)(magnitudes[i] / magintudmax * 4095.0); // Scale to 12 bits
        }

        // --- NEW: Write magnitudes to SD if a full set is complete ---
        if (new_fft_data_complete) {
            printf("Writing magnitudes to SD...\r\n");
            // Adjusted path to write inside the DATA directory
            FRESULT res = write_magnitudes_to_sd("0:/DATA/magnitudes.csv", magnitudes, fft_points/2 + 1);
            if (res == FR_OK) {
                printf("Magnitudes written successfully.\r\n");
            } else {
                printf("Error writing magnitudes to SD: %d\r\n", res);
            }
            new_fft_data_complete = 0; // Reset flag after writing
        }
        // --- END NEW ---

      	startfft = 0;
      }
      else{
		  lsm6dsl_fifo_mode_set(&(MotionSensor.Ctx), LSM6DSL_STREAM_MODE);
		  if(!spi_dma_transfer_error){
			  HAL_TIM_Base_Start_IT(&htim5);
			  Process_FIFO_Data_DMA(last_dma_read_bytes + 1); // +1 for dummy byte
		  }
		  spi_dma_transfer_error = 0;

      }

  }
}

int _write(int fd, char * ptr, int len)
{
  HAL_UART_Transmit(&huart2, (uint8_t *) ptr, len, HAL_MAX_DELAY);
  return len;
}

#if 1
// The MAX_POINTS_BUFFER_SIZE macro was removed as it was not directly used for buffer size
// but for an estimation in the comment, which could cause confusion.
// The `all_points_buffer` now has a more reasonable size for the example `num_points = 4`.
// For a very large number of points, it would be recommended to write directly to the file in a loop,
// or use a dynamic buffer approach.

FRESULT generate_sine_to_csv(const char* filename, double amplitude, double frequency, double duration, int num_points) {
    FIL fil;         // FatFs file object
    FRESULT fr;      // Variable for FatFs return codes
    UINT bytes_written; // Variable to store bytes written by f_write

    // Static buffer for all sine line points.
    // Adjusted for the example size (num_points=4). For more points,
    // a larger buffer would be required or write to the file in segments.
    static char all_points_buffer[256]; // Sufficient for the 4-point example and a margin
    all_points_buffer[0] = '\0'; // Initialize the buffer as an empty string

    // --- 1. Open/Create the file in write mode (FA_WRITE) ---
    // FA_CREATE_ALWAYS: Creates a new file. If it already exists, it overwrites it.
    fr = f_open(&fil, filename, FA_CREATE_ALWAYS | FA_WRITE);
    if (fr != FR_OK) {
        printf("Error: Could not open/create file '%s'. FatFs Code: %d\r\n", filename, fr);
        return fr;
    }

    // --- 2. Generate points and accumulate in the buffer ---
    printf("Generating %d sinusoidal points in the buffer...\r\n", num_points);
    char temp_point_buffer[30]; // Temporary buffer for each individual point

    // Simple estimation to prevent buffer overflow, assumes ~10 chars per point + margin.
    if (num_points * 10 >= sizeof(all_points_buffer) - 50) {
        printf("Error: Number of points (%d) exceeds max supported by static buffer in generate_sine_to_csv.\r\n", num_points);
        f_close(&fil);
        return FR_INVALID_PARAMETER;
    }

    for (int i = 0; i < num_points; ++i) {
        double t = (double)i * duration / (double)(num_points > 1 ? num_points - 1 : 1);
        double value = amplitude * sin(2.0 * M_PI * frequency * t);

        // Format the value and add it to the temporary buffer
        int len = snprintf(temp_point_buffer, sizeof(temp_point_buffer), "%.4f", value);

        // Concatenate the value to the main buffer
        strcat(all_points_buffer, temp_point_buffer);

        // Add a comma if it's not the last point
        if (i < num_points - 1) {
            strcat(all_points_buffer, ",");
        }
    }
    // Add a newline at the end of the point row
    strcat(all_points_buffer, "\n");

    // --- 3. Write the complete buffer to the file ---
    printf("Writing all points to file...\r\n");

    fr = f_write(&fil, all_points_buffer, strlen(all_points_buffer), &bytes_written);

    if (fr != FR_OK || bytes_written < strlen(all_points_buffer)) {
        printf("Error: Could not write all points to '%s'. FatFs Code: %d\r\n", filename, fr);
        f_close(&fil);
        return fr;
    }

    // --- 4. Write the second line to the same file ---
    char second_line_data[] = "Additional experiment data.\n";
    fr = f_write(&fil, second_line_data, strlen(second_line_data), &bytes_written);
    if (fr != FR_OK || bytes_written < strlen(second_line_data)) {
        printf("Error: Could not write second line to '%s'. FatFs Code: %d\r\n", filename, fr);
        f_close(&fil);
        return fr;
    }

    // --- 5. Close the file ---
    fr = f_close(&fil);
    if (fr != FR_OK) {
        printf("Error: Could not close file '%s'. FatFs Code: %d\r\r\n", filename, fr);
        return fr;
    }

    printf("Sinusoidal data (single row) and additional line successfully saved to '%s'\r\n", filename);
    return FR_OK; // Indicate success
}

// --- NEW FUNCTION: write_magnitudes_to_sd ---
/**
  * @brief Writes magnitude array values to a CSV file on SD.
  * Formats each float and writes to the file in 512-byte blocks.
  * Opens the file in append mode to avoid overwriting previous data.
  * @param filename Name of the CSV file on SD (e.g., "0:/magnitudes.csv")
  * @param magnitudes_array Pointer to the float array with magnitudes.
  * @param num_magnitudes Number of elements in the magnitudes_array.
  * @retval FRESULT FatFs operation result code.
  */
FRESULT write_magnitudes_to_sd(const char* filename, float32_t* magnitudes_array, uint16_t num_magnitudes) {
    FIL fil;
    FRESULT fr;
    UINT bytes_written;

    // Buffer to accumulate formatted data before writing in blocks.
    // The size of 512 + 1 (for the null terminator) ensures that
    // a full 512-byte block can be written in a single f_write operation.
    char write_buffer[512 + 1];
    int current_buffer_pos = 0;

    // Open the file in append mode (FA_OPEN_APPEND).
    // If the file does not exist, FA_OPEN_APPEND creates it. If it exists, it
    // positions the write pointer at the end of the file to append new data.
    fr = f_open(&fil, filename, FA_OPEN_APPEND | FA_WRITE);
    if (fr != FR_OK) {
        printf("Error: Could not open/create file '%s'. FatFs Code: %d\r\n", filename, fr);
        return fr;
    }

    // Iterate through magnitudes, format them, and accumulate them in the buffer.
    for (uint16_t i = 0; i < num_magnitudes; ++i) {
        char temp_val_str[20]; // Temporary buffer for a formatted float value (e.g., "-123.4567," consumes ~10-15 chars)
        // Format the magnitude value with 4 decimal places.
        int len = snprintf(temp_val_str, sizeof(temp_val_str), "%.4f", magnitudes_array[i]);

        // Calculate the required space for the current value and a comma (if needed).
        int required_space = len + (i < num_magnitudes - 1 ? 1 : 0); // Length of value + length of comma

        // If adding this value exceeds the write block limit (512 bytes),
        // first write the current buffer content to the file.
        // A margin of 20 is used to ensure that the next value (even a large one)
        // does not overflow the buffer before writing.
        if (current_buffer_pos + required_space >= 512 - 20) {
            fr = f_write(&fil, write_buffer, current_buffer_pos, &bytes_written);
            if (fr != FR_OK || bytes_written != current_buffer_pos) {
                printf("Error writing block to file: %d\r\n", fr);
                f_close(&fil);
                return fr;
            }
            current_buffer_pos = 0; // Reset buffer position after writing
            write_buffer[0] = '\0'; // Clear the buffer for the next block
        }

        // Add the formatted value to the write buffer.
        strcat(write_buffer, temp_val_str);
        current_buffer_pos += len;

        // Add a comma if it's not the last value in the entire magnitudes array.
        if (i < num_magnitudes - 1) {
            strcat(write_buffer, ",");
            current_buffer_pos += 1;
        }
    }

    // After processing all values, write any remaining data in the buffer.
    // Then, add a newline at the end of this "row" of magnitudes for the CSV.
    if (current_buffer_pos > 0) {
        strcat(write_buffer, "\n");
        current_buffer_pos += 1; // For the newline character

        fr = f_write(&fil, write_buffer, current_buffer_pos, &bytes_written);
        if (fr != FR_OK || bytes_written != current_buffer_pos) {
            printf("Error writing final block to file: %d\r\n", fr);
            f_close(&fil);
            return fr;
        }
    }

    // Close the file. It is crucial to close the file after writing to ensure
    // that all cached FatFs data is written to the SD and the file is not corrupted.
    fr = f_close(&fil);
    if (fr != FR_OK) {
        printf("Error: Could not close file '%s'. FatFs Code: %d\r\r\n", filename, fr);
        return fr;
    }

    printf("Magnitude data successfully saved to '%s'\r\n", filename);
    return FR_OK; // Indicate operation success
}
// --- END NEW FUNCTION ---

#endif
/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  * where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
