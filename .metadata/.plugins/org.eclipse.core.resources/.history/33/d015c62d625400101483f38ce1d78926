/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "dac.h"
#include "fatfs.h"
#include "spi.h"
#include "tim.h"
#include "usart.h"
#include "gpio.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "lsm6dsl.h"
#include "stm32l4xx_nucleo_bus.h"
#include <stdio.h>
#include "arm_math.h"
#include <stdarg.h>
#include <string.h>
#include <stdbool.h> // Necesario para 'bool'
//#include "sd_functions.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
// Estas definiciones DEBEN coincidir con tu configuración en CubeMX
#define LSM6DSL_CS_GPIO_PORT     GPIOA  // Ejemplo: Puerto A
#define LSM6DSL_CS_PIN           GPIO_PIN_15 // Ejemplo: Pin 15

// --- Constantes específicas del LSM6DSL ---
#define LSM6DSL_WHO_AM_I_REG     0x0F
#define LSM6DSL_WHO_AM_I_VAL     0x6A // Valor esperado del registro WHO_AM_I
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
// Define max FIFO size in bytes and words
#define FIFO_MAX_BYTES      4096
#define FIFO_MAX_WORDS      (FIFO_MAX_BYTES / 2)
#define ACCEL_WORDS_PER_SET 3 // Ax, Ay, Az (16 bits cada uno)
#define ACCEL_BYTES_PER_SET (ACCEL_WORDS_PER_SET * 2)
#define FIFO_MAX_SETS       (FIFO_MAX_WORDS / ACCEL_WORDS_PER_SET) // Max sets (~682)
uint8_t dma_tx_buffer[FIFO_MAX_BYTES + 1]; // +1 para el byte de comando
uint8_t dma_rx_buffer[FIFO_MAX_BYTES + 1]; // +1 para el byte basura recibido al inicio
// --- Tamaño del buffer de lectura local ---
// Leer chunks más pequeños puede ayudar a evitar bloqueos largos
// Ajusta según la memoria disponible y la velocidad de procesamiento
// Un valor entre 256 y 1024 podría ser un buen punto de partida.
#define READ_BUFFER_BYTES   4096 // Leer hasta 512 bytes (~85 sets) a la vez
#if (READ_BUFFER_BYTES > FIFO_MAX_BYTES)
#error READ_BUFFER_BYTES cannot be larger than FIFO_MAX_BYTES
#endif
#define MAX_SETS_PER_READ   (READ_BUFFER_BYTES / ACCEL_BYTES_PER_SET)
// --- Configuración Watermark ---
#define FIFO_WATERMARK_WORDS 2020 // Umbral cercano al máximo (Max FTH es 2047)
#if (FIFO_WATERMARK_WORDS > 2047)
#error FIFO_WATERMARK_WORDS cannot exceed 2047
#endif

#define fft_points 1024
#define NUM_MUESTRAS 682
#define LINES_PER_MAG_FILE 10 // NEW: Número de líneas a escribir por archivo de magnitudes
#define comments
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */
extern SPI_HandleTypeDef hspi3; // SPI para acelerómetro
extern SPI_HandleTypeDef hspi2; // SPI para SD Card

arm_rfft_fast_instance_f32 fft_instance;
uint8_t full_fifo_buffer[FIFO_MAX_BYTES]; // Not used in this direct read
uint8_t fifo_chunk_buffer[READ_BUFFER_BYTES]; // Local buffer for reading FIFO data
//int32_t raw_x_values[NUM_MUESTRAS]; // Sufficient size
//int32_t raw_y_values[NUM_MUESTRAS];
int32_t raw_z_values[NUM_MUESTRAS]; // Raw sensor data

// Buffers para valores CONVERTIDOS a mg (almacenados en 32 bits)
float32_t mg_x_values[NUM_MUESTRAS]; // Processed sensor data
//float32_t mg_y_values[NUM_MUESTRAS];
//float32_t mg_z_values[NUM_MUESTRAS];


float32_t fft_z[fft_points];
float32_t magnitudes[fft_points/2 + 1];
// Reintroducción de magnitudesssd con alineación explícita.
// Esta copia es necesaria para evitar problemas de race condition con 'magnitudes'.
float32_t magnitudesssd0[fft_points/2+1] __attribute__((aligned(4))) = {0};
float32_t fft_in[fft_points] = {0}; // Buffer para acumular datos para la FFT
float32_t fft_in2[fft_points]; // Buffer intermedio para la FFT (copia de fft_in)
int counterzzz= 0;
uint16_t dac_buffer[fft_points/2 + 1]; // Buffer para DAC (DMA ya no usado aquí)

// NEW: Variables para el manejo de nombres de archivo secuenciales
static int magnitude_file_idx = 0; // Índice para el nombre del archivo de magnitudes (0 = magnitudes.csv, 1 = magnitudes1.csv, etc.)
char current_magnitudes_filename[50]; // Buffer para construir el nombre del archivo actual
static int lines_in_current_file_counter = 0; // Contador de líneas escritas en el archivo actual

// NEW: Semáforo para controlar el acceso a la escritura en SD
volatile bool sd_write_in_progress = false; // Bandera para controlar si hay una escritura en SD en curso

float cached_acc_sensitivity = 0.0f; // Cache sensitivity
LSM6DSL_Object_t MotionSensor;
volatile uint32_t dataRdyIntReceived;
uint32_t time, difftime;
uint8_t lsm6dsl_init_status_spi = 0;

uint8_t fifo_was_full_last_time = 0;

// uint8_t dma_tx_buffer[FIFO_MAX_BYTES + 1]; // ELIMINADO: No usado en modo sin DMA
// uint8_t dma_rx_buffer[FIFO_MAX_BYTES + 1]; // ELIMINADO: No usado en modo sin DMA
volatile uint8_t fifo_int_triggered = 0;   // Flag para la interrupción INT1 (Todavía se usa para la señal)
volatile uint8_t spi_dma_transfer_complete = 0; // ELIMINADO: No usado en modo sin DMA
volatile uint8_t spi_dma_transfer_error = 0;    // ELIMINADO: No usado en modo sin DMA
uint16_t last_dma_read_bytes = 0; // Todavía útil para saber cuántos bytes leer en SPI polling

// Banderas para controlar el flujo en el bucle principal
volatile uint8_t process_fifo_flag = 0; // Flag para indicar que hay datos de FIFO para procesar
volatile uint8_t calculate_fft_flag = 0; // Flag para indicar que es momento de calcular la FFT
static int current_accumulated_sets = 0; // Acumulador para saber cuántos sets de FIFO se han leído

// NEW: Variables globales para el manejo de la SD (para poder remountar)
FATFS fs; // Objeto del sistema de archivos (se mantiene global como 'fs')
char MiSdPath[4] = "0:/"; // Ruta ej: "0:/"

// DAC specific variables (for manual update)
volatile bool dac_update_flag = false; // Flag to trigger DAC update in main loop
static uint16_t dac_current_sample_idx = 0; // Index for manual DAC buffer reading

FRESULT generate_sine_to_csv(const char* filename, double amplitude, double frequency, double duration, int num_points);
// Modificada para aceptar el modo de apertura
FRESULT write_magnitudes_to_sd(const char* filename, float32_t* magnitudes_array, uint16_t num_magnitudes, bool is_new_file);
static uint8_t new_fft_data_complete = 0; // Flag to indicate a full set of FFT data is ready for writing
static uint8_t sd_transfer_start = 0; // Not used in no-DMA version
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */
static void MEMS_Init_SPI_FIFO_Int(void);
// static void Start_FIFO_Read_DMA(void); // ELIMINADO: Reemplazado por Start_FIFO_Read_Polling
static void Start_FIFO_Read_Polling(void); // NEW: Función para lectura SPI sin DMA
static void Process_FIFO_Data_Polling(uint16_t bytes_received_incl_dummy); // NEW: Procesa datos leídos por polling
// static void Process_FIFO_Data_DMA(uint16_t bytes_received_incl_dummy); // ELIMINADO
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
int firststart = 1;
int finish = 0; int startfft = 0; int movefft = 0;
// ELIMINADO: No hay callback DMA para lectura/copia de acelerómetro
// void HAL_DMA_Callback(DMA_HandleTypeDef *hdma){ ... }

// FATFS fs; // Ya global, declarada en PV
FIL fil; // File object for local use in functions
FILINFO fno; // File info object for local use
FRESULT fresult; // Result for FatFs functions (already global)
UINT br, bw; // File read/write count (local to functions)

/**** capacity related *****/
FATFS *pfs;
DWORD fre_clust;
uint32_t total, free_space;

#define BUFFER_SIZE 128
char buffer[BUFFER_SIZE]; // to store strings..

int i=0;

int bufsize (char *buf)
{
	int i=0;
	while (*buf++ != '\0') i++;
	return i;
}

void clear_buffer (void)
{
	for (int i=0; i<BUFFER_SIZE; i++) buffer[i] = '\0';
}

void send_uart (char *string)
{
	uint8_t len = strlen (string);
	HAL_UART_Transmit(&huart2, (uint8_t *) string, len, HAL_MAX_DELAY); // transmit in blocking mode
}

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

    // Initialize the FFT instance (this was commented out, but is essential for FFT operations)
	arm_status status_fft = arm_rfft_fast_init_f32(&fft_instance, fft_points);
	if (status_fft != ARM_MATH_SUCCESS) {
		printf("Error: Failed to initialize RFFT instance.\r\n");
		Error_Handler();
	}
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_USART2_UART_Init();
  MX_DAC1_Init();
  MX_SPI2_Init();
  MX_FATFS_Init();
  MX_TIM2_Init();
  MX_TIM5_Init();
  MX_TIM4_Init();
  MX_TIM6_Init();
  /* USER CODE BEGIN 2 */

 HAL_TIM_Base_Start(&htim2);
  printf("Starting\r\n");
/*
      char MiSdPath[4] = "0:/"; // Ruta ej: "0:/"

      // Attempt to mount the SD card
      FRESULT mount_res = f_mount(&fs, MiSdPath, 1);
      if (mount_res == FR_OK) {
   	   printf("SD montada....\r\n");
    } else {
   	   printf("Error al montar la SD Card. Codigo FatFs: %d\r\n", mount_res); // Print detailed error for mount
      }

      printf("---- LSM6DSL FIFO Interrupt + Polling SPI (Accel Z @ 6.66kHz) ----\r\n"); // Mensaje actualizado
       MEMS_Init_SPI_FIFO_Int(); // Llama a la inicialización correcta
      HAL_Delay(10);
       HAL_TIM_Base_Start_IT(&htim5); // TIM5 para disparar lectura del acelerómetro

         if(HAL_TIM_Base_Start(&htim6) != HAL_OK)
       {
           printf("Error iniciando TIM6!\r\n");
           Error_Handler();
       }

      // DAC sin DMA: Inicializar DAC pero no DMA
      if(HAL_DAC_Start(&hdac1, DAC_CHANNEL_1) != HAL_OK) // Solo HAL_DAC_Start
      {
          printf("Error iniciando DAC1_CH1!\r\n"); // Mensaje actualizado
          Error_Handler();
      }
      // NEW: Iniciar TIM6 para disparar la actualización del DAC periódicamente
*/
      HAL_TIM_Base_Start_IT(&htim6);


  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
      // --- Proceso de lectura de FIFO y FFT ---
      if (process_fifo_flag) { // Si hay nuevos datos del FIFO para procesar
          process_fifo_flag = 0; // Resetear la bandera inmediatamente
          // Ejecuta la lectura del FIFO y la copia a fft_in
          // Aquí mg_x_values se llena y luego se copia a fft_in
          Process_FIFO_Data_Polling(last_dma_read_bytes + 1); // Ahora llama a la versión de polling
#ifdef comments
          printf("vuelta al while\r\n");
#endif
      }


      // --- Cálculo de FFT ---
      if (calculate_fft_flag) { // Si la copia a fft_in2 está lista para FFT
          calculate_fft_flag = 0; // Resetear la bandera
          printf("t: %d\r\n",counterzzz); // Imprime el counterzzz (debería ser 0 si no se salta ciclos)
          counterzzz = 0; // Reinicia el contador

          int STARTtiempofft = TIM2->CNT; // Inicia el cronómetro para FFT
          arm_rfft_fast_f32(&fft_instance,fft_in2,fft_z, 0); // Realiza la FFT
          // Calcular DC y Nyquist por separado
          magnitudes[0] = fabsf(fft_z[0]);
          #if (fft_points % 2 == 0) // Si N es par, hay componente Nyquist
            magnitudes[fft_points/2] = fabsf(fft_z[1]);
          #endif
          arm_cmplx_mag_f32(&fft_z[2], &magnitudes[1], (fft_points - 2) / 2);
          int tiempofft =  TIM2->CNT -STARTtiempofft; // Finaliza el cronómetro
#ifdef comments
          printf("FFT tiempo: %.4f ms\r\n", tiempofft/80000.0);
#endif

          // Señalizar que los datos de FFT están listos para la SD y/o DAC
          // Este flag ya NO es un semáforo binario de estado (1 o 2), es solo una notificación
          // de que los datos de 'magnitudes' están actualizados.
          new_fft_data_complete = 1;

          // Escalar magnitudes para DAC
          float magintudmax = 0.0f; // Inicializa a 0.0f
          // Encuentra el máximo para escalar, evitando valores muy pequeños al inicio
          if (fft_points/2 + 1 > 100) {
            for(int k = 100; k < fft_points/2 + 1; k++) {
                if(magnitudes[k] > magintudmax) {
                    magintudmax = magnitudes[k];
                }
            }
          } else {
              magintudmax = magnitudes[0];
              for(int k = 1; k < fft_points/2 + 1; k++) {
                  if(magnitudes[k] > magintudmax) {
                      magintudmax = magnitudes[k];
                  }
              }
          }

          for(int k = 0; k < fft_points/2 + 1; k++) {
              if (magintudmax > 0.0f) {
                  dac_buffer[k] = (uint16_t)(magnitudes[k] / magintudmax * 4095.0);
              } else {
                  dac_buffer[k] = 0;
              }
          }

          // Dac manual update needs its own flag for TIM6 to trigger it.
          dac_current_sample_idx = 0; // Reset DAC sample index
          dac_update_flag = true; // Signal TIM6 callback to start DAC update loop

          // Reiniciar el FIFO del sensor y el timer de lectura (ya no directamente desde TIM4)
          lsm6dsl_fifo_mode_set(&(MotionSensor.Ctx), LSM6DSL_BYPASS_MODE); HAL_Delay(1);
          lsm6dsl_fifo_mode_set(&(MotionSensor.Ctx), LSM6DSL_STREAM_MODE);
          HAL_TIM_Base_Start_IT(&htim5); // Reiniciar el timer para la siguiente lectura del FIFO
      }

      // --- Actualización manual del DAC ---
      // Si dac_update_flag es true, el TIM6 callback estará escribiendo samples.
      // Esta lógica aquí es si se quiere hacer de forma no bloqueante en el main loop,
      // pero el DAC se hará con un timer + polling en su ISR.

      // --- Escritura de Magnitudes a SD ---
      // Solo intenta escribir si hay nuevos datos de FFT disponibles Y la SD NO está ocupada.
      if (new_fft_data_complete && !sd_write_in_progress) {
          sd_write_in_progress = true; // Bloquea nuevas solicitudes de escritura SD
          printf("Writing magnitudes to SD...\r\n");

          // Construir el nombre del archivo dinámicamente
          if (magnitude_file_idx == 0) {
              snprintf(current_magnitudes_filename, sizeof(current_magnitudes_filename), "0:/magnitudes.csv");
          } else {
              snprintf(current_magnitudes_filename, sizeof(current_magnitudes_filename), "0:/magnitudes%d.csv", magnitude_file_idx);
          }

          FRESULT res;
          int retry_count = 0;
          const int MAX_RETRIES = 3;
          bool write_succeeded = false;
          bool create_new_file_mode = (lines_in_current_file_counter == 0);

          do {
              memcpy(magnitudesssd0, magnitudes, sizeof(magnitudesssd0)); // Copia la FFT a un buffer estable
              res = write_magnitudes_to_sd(current_magnitudes_filename, magnitudesssd0, fft_points/2 + 1, create_new_file_mode);

              if (res == FR_OK) {
#ifdef comments
                  printf("Magnitudes written successfully to '%s' (line %d). Total for file: %d.\r\r\n",
                         current_magnitudes_filename, lines_in_current_file_counter + 1, lines_in_current_file_counter + 1);
#endif
                  write_succeeded = true;
                  lines_in_current_file_counter++;
              } else {
                  printf("Error writing magnitudes to SD: %d to '%s'. Attempting remount and retry (%d/%d).\r\n", res, current_magnitudes_filename, retry_count + 1, MAX_RETRIES);

                  FRESULT unmount_res = f_mount(NULL, MiSdPath, 0);
                  if (unmount_res == FR_OK) { printf("SD Card unmounted successfully.\r\n"); } else { printf("Error unmounting SD Card. FatFs Code: %d\r\n", unmount_res); }

                  HAL_Delay(100);

                  FRESULT mount_res_retry = f_mount(&fs, MiSdPath, 1);
                  if (mount_res_retry == FR_OK) {
                      printf("SD Card remounted successfully.\r\n");
                      DWORD free_clusters_remount; FATFS* filesystem_obj_remount;
                      if (f_getfree(MiSdPath, &free_clusters_remount, &filesystem_obj_remount) == FR_OK) {
                          printf("SD Card: Total space: %luKB, Free space: %luKB after remount.\r\n",
                                 (filesystem_obj_remount->n_fatent - 2) * filesystem_obj_remount->csize / 2,
                                 free_clusters_remount * filesystem_obj_remount->csize / 2);
                      }
                      create_new_file_mode = true;
                  } else {
                      printf("CRITICAL ERROR: Failed to remount SD Card. FatFs Code: %d. No further retries for this file.\r\n", mount_res_retry);
                      retry_count = MAX_RETRIES;
                  }
              }
              retry_count++;
          } while (!write_succeeded && retry_count < MAX_RETRIES);

          if (!write_succeeded) {
              printf("All retries failed for '%s'. Moving to next file index.\r\n", current_magnitudes_filename);
              magnitude_file_idx++;
              lines_in_current_file_counter = 0;
          } else if (lines_in_current_file_counter >= LINES_PER_MAG_FILE) {
#ifdef comments
              printf("%d lines written to '%s'. Moving to next file.\r\n", LINES_PER_MAG_FILE, current_magnitudes_filename);
#endif
              magnitude_file_idx++;
              lines_in_current_file_counter = 0;
          }
          new_fft_data_complete = 0; // La FFT está procesada, resetear flag para siguiente
          sd_write_in_progress = false; // Desactiva la bandera: SD está libre
      }

      counterzzz++; // Contador para monitoreo general

      HAL_Delay(1); // Ceder tiempo
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 1;
  RCC_OscInitStruct.PLL.PLLN = 10;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */



int32_t SPI_Send(void *ignored_handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
    uint16_t transfer_size = 1 + Length;
    int32_t ret = BSP_ERROR_NONE; // 0
    // Buffer local para la transmisión completa
    uint8_t tx_buffer[transfer_size];
    // Preparar comando de escritura (MSB=0 para escribir)
    tx_buffer[0] = 0x7F & Reg; // Pone a 0 el bit 7
    memcpy(&tx_buffer[1], pData, Length);

    GPIOA->BSRR = GPIO_PIN_1 << 16; // Set pin to low (CS low)
    // Usar polling para SPI Transmit
    if (HAL_SPI_Transmit(&hspi3, tx_buffer, transfer_size, HAL_MAX_DELAY) != HAL_OK) // Sin DMA
    {
         printf("BSP_SPI3_Send: HAL_SPI_Transmit failed!\r\n");
         ret = BSP_ERROR_UNKNOWN_FAILURE; // O un código de error más específico
    }
    GPIOA->BSRR = GPIO_PIN_1; // Set pin to high (CS high)
    return ret;
}

int32_t SPI_Recv(void *handle, uint8_t reg, uint8_t *data, uint16_t len)
{

    uint16_t transfer_size = 1 + len;
    uint8_t tx_buffer[transfer_size];
    uint8_t rx_buffer[transfer_size];

    tx_buffer[0] = 0x80 | reg; // Prepare read command (MSB=1 for read)

    // Rellenar resto de Tx con dummy bytes (0x00 o 0xFF)
    for (uint16_t i = 1; i < transfer_size; i++) {
        tx_buffer[i] = 0x00; // Or 0xFF
    }

    time = TIM2->CNT;
    GPIOA->BSRR = GPIO_PIN_1<< 16; // Set pin to low (CS low)
    // Usar polling para SPI TransmitReceive
    HAL_StatusTypeDef status = HAL_SPI_TransmitReceive(&hspi3, tx_buffer, rx_buffer, transfer_size, HAL_MAX_DELAY); // Sin DMA
    GPIOA->BSRR = GPIO_PIN_1 ; // Set pin to high (CS high)

   difftime = TIM2->CNT - time;
    if (status == HAL_OK) {
        memcpy(data, &rx_buffer[1], len); // Copy received data, excluding the first dummy byte
        return 0; // Success (LSM6DSL_OK)
    } else {
        // HAL communication error
        printf("BSP_SPI3_Recv: HAL_SPI_TransmitReceive failed with status: %d\r\n", status);
        // Devolver un código de error. Podrías mapear HAL_ERROR, HAL_TIMEOUT etc. a errores específicos.
        if (status == HAL_TIMEOUT) {
             return -2; // Ejemplo para timeout
        } else {
             return -1; // Generic error (LSM6DSL_ERROR)
        }
    }
}

static void MEMS_Init_SPI_FIFO_Int(void)
{
    LSM6DSL_IO_t io_ctx;
    uint8_t id;
    int32_t status;
    lsm6dsl_int1_route_t int1_route; // To configure INT1
    float sens_a;

    printf("Configuring I/O SPI interface...\r\n");
    // Configure io_ctx (SPI_4WIRES, SPI_Send/Recv, etc.)
    io_ctx.Init = BSP_SPI3_Init;
    io_ctx.DeInit = BSP_SPI3_DeInit;
    io_ctx.BusType = LSM6DSL_SPI_4WIRES_BUS;
    io_ctx.Address = 0;
    io_ctx.WriteReg = SPI_Send;
    io_ctx.ReadReg = SPI_Recv;
    io_ctx.GetTick = BSP_GetTick;

    status = LSM6DSL_RegisterBusIO(&MotionSensor, &io_ctx);
    if (status != LSM6DSL_OK) { printf("E:RegBusIO(%ld)\r\n", status); Error_Handler(); return; }

    printf("Reading WHO_AM_I...\r\n");
    status = LSM6DSL_ReadID(&MotionSensor, &id);
    if (status != LSM6DSL_OK) { printf("E:ReadID(%ld)\r\n", status); Error_Handler(); return; }
    printf("WHO_AM_I = 0x%02X\r\n", id);
    if (id != LSM6DSL_ID) { printf("E:WrongID\r\n"); Error_Handler(); return; }

    printf("LSM6DSL detected! Initializing...\r\n");
    status = LSM6DSL_Init(&MotionSensor);
    if (status != LSM6DSL_OK) { printf("E:Init(%ld)\r\n", status); Error_Handler(); return; }

    // --- Configure Sensors ---
    printf("Configuring Accel at 6.66 kHz, Gyro OFF...\r\n");
    status = LSM6DSL_ACC_SetOutputDataRate(&MotionSensor, 6660.0f);
    if (status != LSM6DSL_OK) { printf("E:AccODR(%ld)\r\n", status); Error_Handler(); return; }
    status = LSM6DSL_ACC_SetFullScale(&MotionSensor, 4);
    if (status != LSM6DSL_OK) { printf("E:AccFS(%ld)\r\n", status); Error_Handler(); return; }
    status = LSM6DSL_GYRO_Disable(&MotionSensor);
    if (status != LSM6DSL_OK) { printf("E:GyroDis(%ld)\r\n", status); Error_Handler(); return; }
    if (LSM6DSL_ACC_GetSensitivity(&MotionSensor, &cached_acc_sensitivity) != LSM6DSL_OK) {
         printf("E:GetSens\r\n"); Error_Handler(); return;
    }
    printf("Accel Sensitivity: %.3f mg/LSB\r\n", cached_acc_sensitivity);

    // --- Configurar FIFO ---
    printf("Configuring FIFO (6.66kHz, Accel Only, Stream Mode, WTM=%d, StopOnWTM=0)...\r\n", FIFO_WATERMARK_WORDS);
    status = LSM6DSL_FIFO_Set_ODR_Value(&MotionSensor, 6660.0f);
    if (status != LSM6DSL_OK) { printf("E:FifoODR(%ld)\r\n", status); Error_Handler(); return; }
    status = LSM6DSL_FIFO_ACC_Set_Decimation(&MotionSensor, LSM6DSL_FIFO_XL_NO_DEC);
    if (status != LSM6DSL_OK) { printf("E:FifoAccDec(%ld)\r\n", status); Error_Handler(); return; }
    status = LSM6DSL_FIFO_GYRO_Set_Decimation(&MotionSensor, LSM6DSL_FIFO_GY_DISABLE);
    if (status != LSM6DSL_OK) { printf("E:FifoGyroDec(%ld)\r\n", status); Error_Handler(); return; }

    // Configurar Nivel de Watermark
    status = LSM6DSL_FIFO_Set_Watermark_Level(&MotionSensor, FIFO_WATERMARK_WORDS);
    if (status != LSM6DSL_OK) { printf("E:SetWTM(%ld)\r\n", status); Error_Handler(); return; }

    // Asegurarse que "Stop on Watermark" está DESACTIVADO (para modo Stream real)
    status = lsm6dsl_fifo_stop_on_wtm_set(&(MotionSensor.Ctx), 0); // 0 = Disabled
     if (status != LSM6DSL_OK) { printf("E:StopOnWTM(%ld)\r\n", status); Error_Handler(); return; }

    // --- Configurar Interrupción INT1 para Watermark ---
    // Asegúrate que el pin EXTI (LSM6DSL_INT1_PIN) está configurado en CubeMX
    printf("Configurando INT1 para FIFO Watermark...\r\n");
    status = lsm6dsl_pin_int1_route_get(&(MotionSensor.Ctx), &int1_route);
     if (status != LSM6DSL_OK) { printf("E:GetInt1Route(%ld)\r\n", status); Error_Handler(); return; }
    // Habilitar SOLO la interrupción de watermark en INT1
    int1_route.int1_fth = 1;
    int1_route.int1_fifo_ovr = 0; // Deshabilitar OVF en INT1 (lo chequeamos por status)
    int1_route.int1_full_flag = 0;
    int1_route.int1_drdy_xl = 0; // Deshabilitar DRDY si no se usa
    //... deshabilita otras fuentes si es necesario ...
    status = lsm6dsl_pin_int1_route_set(&(MotionSensor.Ctx), int1_route);
    if (status != LSM6DSL_OK) { printf("E:SetInt1Route(%ld)\r\n", status); Error_Handler(); return; }
    // Puedes configurar Latch/Pulse, Active High/Low aquí si es necesario
    // lsm6dsl_int_notification_set(...)
    // lsm6dsl_pin_polarity_set(...)

    // --- Iniciar operación ---
    // Poner en modo Stream (esto también debería limpiar la FIFO)
    status = LSM6DSL_FIFO_Set_Mode(&MotionSensor, LSM6DSL_STREAM_MODE);
    if (status != LSM6DSL_OK) { printf("E:FifoSetMode(%ld)\r\n", status); Error_Handler(); return; }

    printf("Activando Acelerómetro...\r\n");
    status = LSM6DSL_ACC_Enable(&MotionSensor);
    if (status != LSM6DSL_OK) { printf("E:AccEnable(%ld)\r\n", status); Error_Handler(); return; }

    printf("LSM6DSL configurado para Int. Watermark (%d words) a 6.66kHz (Solo Accel, Stream Mode).\r\n", FIFO_WATERMARK_WORDS);
    printf("Esperando interrupciones en pin %d...\n", LSM6DSL_INT1_PIN);

    lsm6dsl_init_status_spi = 1;
    fifo_int_triggered = 0; // Asegurar flag limpio
    // spi_dma_transfer_complete = 0; // No usado
    // spi_dma_transfer_error = 0;    // No usado
}

/**
  * @brief Inicia la lectura de la FIFO usando SPI Polling (sin DMA).
  * Llamada desde TIM5_Callback.
  */

uint16_t num_words_available = 0;
uint16_t bytes_to_read = 0;
int32_t status;
static void Start_FIFO_Read_Polling(void) // Renombrada de Start_FIFO_Read_DMA
{
    if (!lsm6dsl_init_status_spi) return;

    num_words_available = 0;
    bytes_to_read = 0;

    // Leer nivel FIFO
    status = LSM6DSL_FIFO_Get_Num_Samples(&MotionSensor, &num_words_available);
    //if (status != LSM6DSL_OK) { printf("E:StartRead_GetSamples(%ld)\r\n", status); return; }

    // Determinar cuántos bytes leer (no exceder buffer ni FIFO max)
    bytes_to_read = num_words_available * 2;
    if (bytes_to_read == 0) return; // Nada que leer
    if (bytes_to_read > FIFO_MAX_BYTES) {
        printf("WARN: FIFO level %u > Buffer! Clipping to %d bytes.\r\n", bytes_to_read, FIFO_MAX_BYTES);
        bytes_to_read = FIFO_MAX_BYTES;
    }
#ifdef comments
    printf("POLLING SPI! Leyendo %u palabras (%u bytes)...\r\n", num_words_available, bytes_to_read); // Mensaje actualizado
#endif
    last_dma_read_bytes = bytes_to_read; // Todavía útil para saber cuántos bytes procesar

    uint8_t tx_cmd_buffer[bytes_to_read + 1]; // Comando + bytes dummy para TX
    uint8_t rx_data_buffer[bytes_to_read + 1]; // Buffer para RX

    // Buffer TX: Comando de lectura + Dummies
    tx_cmd_buffer[0] = LSM6DSL_FIFO_DATA_OUT_L | 0x80; // Comando Leer desde FIFO_DATA_OUT_L
    memset(&tx_cmd_buffer[1], 0x00, bytes_to_read); // Dummies

    time = TIM2->CNT; // Inicia tiempo para medir duración de la transacción SPI

    GPIOA->BSRR = GPIO_PIN_1 << 16; // CS Bajo (Activar esclavo)
    // Transferencia SPI en modo bloqueante (polling)
    HAL_StatusTypeDef spi_status = HAL_SPI_TransmitReceive(&hspi3,
                                                           tx_cmd_buffer,
                                                           rx_data_buffer, // Leer en buffer RX
                                                           bytes_to_read + 1, // Tamaño total = Comando + Datos
                                                           HAL_MAX_DELAY); // Bloqueante

    GPIOA->BSRR = GPIO_PIN_1; // CS Alto (Desactivar esclavo)
    difftime = TIM2->CNT - time; // Finaliza tiempo

    if (spi_status != HAL_OK) {
        printf("E:HAL_SPI_TransmitReceive (Polling) (%d)\r\n", spi_status); // Mensaje actualizado
        spi_dma_transfer_error = 1; // Aunque no es DMA, aún es un error de transferencia
        // Resetear FIFO?
        lsm6dsl_fifo_mode_set(&(MotionSensor.Ctx), LSM6DSL_BYPASS_MODE); HAL_Delay(1);
        lsm6dsl_fifo_mode_set(&(MotionSensor.Ctx), LSM6DSL_STREAM_MODE);
    } else {
        // Datos leídos, ahora se procesan. Esto reemplaza el rol del DMA Callback para la copia.
        Process_FIFO_Data_Polling(last_dma_read_bytes + 1); // Llama a la nueva función de procesamiento
    }
    // HAL_TIM_Base_Start_IT(&htim5); // Se reinicia TIM5 en el TIM4_Callback (al final del proceso FFT)
}

const int INITIAL_BUFFER_OFFSET = 1;
/**
  * @brief Procesa los datos recibidos vía SPI Polling desde la FIFO (solo eje X).
  * Esta función ahora es llamada directamente desde Start_FIFO_Read_Polling.
  */
static void Process_FIFO_Data_Polling(uint16_t bytes_received_incl_dummy) // Renombrada de Process_FIFO_Data_DMA
{
    uint32_t time_us = difftime / 80;
#ifdef comments
    printf("Polling SPI Completed in (%lu ticks = ~%lu us)....\r\r\n", time_us); // Mensaje actualizado
#endif

    if (cached_acc_sensitivity == 0.0f || bytes_received_incl_dummy <= 1) return;

    uint16_t bytes_accel_data = bytes_received_incl_dummy - 1; // Datos reales (sin el primer byte basura)
    uint16_t sets_leidos = bytes_accel_data / ACCEL_BYTES_PER_SET;
    // Se asume que rx_data_buffer es accesible aquí, o se pasa como parámetro
    // Dado que rx_data_buffer era local a Start_FIFO_Read_Polling, necesitamos una forma de accederlo.
    // La forma más simple para esta adaptación es mover el procesamiento del buffer localmente
    // o hacer rx_data_buffer global (menos recomendado por RAM).
    // Para simplificar, asumiremos que rx_data_buffer es el dma_rx_buffer temporalmente para la conversión
    // ya que su estructura es similar, PERO EN UNA IMPLEMENTACIÓN REAL, DEBERÍAS PASAR EL rx_data_buffer.
    // O mejor aún, como dma_rx_buffer es global, reutilizarlo para la lectura SPI polling.
    // Vamos a ajustar Start_FIFO_Read_Polling para que escriba directamente en dma_rx_buffer global.

    uint8_t* data_start_ptr = dma_rx_buffer + INITIAL_BUFFER_OFFSET; // Asumiendo dma_rx_buffer global se usó

#ifdef comments
    printf("--- Processing %u Polling sets ---\r\n", sets_leidos); // Mensaje actualizado
#endif
    for (int i = 0; i < sets_leidos; i++) {
        uint8_t* pSampleBytes = data_start_ptr + (i * ACCEL_BYTES_PER_SET);
        // raw_x_values[i] = (int16_t)(((uint16_t)pSampleBytes[1] << 8) | pSampleBytes[0]); // Si se usa X
        // raw_z_values[i] = (int16_t)(((uint16_t)pSampleBytes[5] << 8) | pSampleBytes[4]); // Si se usa Z (como en tu original)
        // Para consistencia con tu último código que usaba raw_z_values para mg_x_values:
        raw_z_values[i] = (int16_t)(((uint16_t)pSampleBytes[5] << 8) | pSampleBytes[4]);
        mg_x_values[i] = (float32_t)((float)raw_z_values[i] * cached_acc_sensitivity);
    }

    // Copia los nuevos datos de mg_x_values al buffer global fft_in
    // Esto ya NO es DMA Mem-to-Mem, es un memcpy CPU-bound.
    memcpy(&fft_in[current_accumulated_sets], mg_x_values, sets_leidos * sizeof(float32_t));
    current_accumulated_sets += sets_leidos;

    // Check if a full set of data for FFT has been accumulated
    if (current_accumulated_sets >= fft_points) { // Use fft_points (4096) for consistency with FFT
        // new_fft_data_complete = 1; // No se usa directamente aquí, se establece por la señal del TIM4
        // En lugar de una bandera separada, la FFT se activa directamente.
        // Copiar fft_in a fft_in2 para el cálculo de FFT. Esto antes era DMA, ahora es memcpy.
        memcpy(fft_in2, fft_in, fft_points * sizeof(float32_t));
        calculate_fft_flag = 1; // Activa la bandera para que el main loop calcule la FFT
        current_accumulated_sets = 0; // Reset para el siguiente ciclo de acumulación
    }
    #ifdef comments
    printf("Processed %u sets (%u bytes)\r\n", sets_leidos, bytes_accel_data); // Mensaje actualizado
    #endif
}

// ELIMINADO: Ya no hay callback DMA para SPI. HAL_SPI_TransmitReceive es bloqueante.
// void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi) { ... }

// HAL_SPI_ErrorCallback se mantiene por si hay errores en las llamadas a HAL_SPI_TransmitReceive bloqueantes.

// HAL_DAC_ConvCpltCallbackCh1 se mantiene, pero la DAC ahora se actualiza manualmente o con un timer+polling

/**
  * @brief Callback del TIM5 (dispara lectura de FIFO - ahora Polling).
  * @param htim Puntero al handle del timer.
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim){
  static int count = 0;
  if (htim->Instance == TIM5) {
#ifdef comments
	  printf("(%.1f) TIM5 Callback\r\n",(TIM2->CNT)/80.0);
	  printf("TIM5 Periodo: %.1f us\r\r\n", (TIM2->CNT-count)/80.0f);
#endif
    HAL_TIM_Base_Stop_IT(&htim5); // Detener el timer
    Start_FIFO_Read_Polling(); // LLAMA A LA FUNCIÓN DE POLLING
    count = TIM2->CNT;
  }
  // NEW: Callback para TIM6 (actualización del DAC, ahora por polling en la ISR)
  if (htim->Instance == TIM6) {
      if (dac_update_flag) {
          if (dac_current_sample_idx < (fft_points/2 + 1)) {
              // Escribir el valor al DAC manualmente
              HAL_DAC_SetValue(&hdac1, DAC_CHANNEL_1, DAC_ALIGN_12B_R, dac_buffer[dac_current_sample_idx]);
              dac_current_sample_idx++;
          } else {
              dac_current_sample_idx = 0; // Reset index for continuous play
              dac_update_flag = false; // Stop updating if finished a full cycle
          }
      }
  }

  if(htim->Instance == TIM4){ // Este timer era para disparar la FFT antes
#ifdef comments
	  printf("(%.1f) TIM4 Callback\r\n",(TIM2->CNT)/80.0);
#endif
	  HAL_TIM_Base_Stop_IT(&htim4); // Se detiene hasta que la FFT termine en main
      // Ya no dispara directamente la FFT desde aquí.
      // La bandera calculate_fft_flag se establecerá en Process_FIFO_Data_Polling,
      // y el main loop la detectará para ejecutar la FFT.
      // Aquí solo se re-habilita TIM5 si no hubo error SPI
      if(!spi_dma_transfer_error){ // spi_dma_transfer_error ahora es un flag de error general de SPI
          // HAL_TIM_Base_Start_IT(&htim5); // Esto ya se hace en main después de FFT/SD
      }
      spi_dma_transfer_error = 0; // Resetear error
  }
}

int _write(int fd, char * ptr, int len)
{
  HAL_UART_Transmit(&huart2, (uint8_t *) ptr, len, HAL_MAX_DELAY);
  return len;
}

#if 1
#define MAX_POINTS_BUFFER_SIZE (4 * 16) // Aproximadamente 65KB

FRESULT generate_sine_to_csv(const char* filename, double amplitude, double frequency, double duration, int num_points) {
    FIL fil;         // Objeto de archivo FatFs
    FRESULT fr_open;
    FRESULT fr_write_block; // Para resultados intermedios de escritura
    FRESULT fr_close;
    UINT bytes_written;
    FRESULT final_res = FR_OK; // Asume éxito a menos que ocurra un error

    // Buffer estático para todos los puntos de la línea sinusoidal.
    // Ajustado para el tamaño del ejemplo (num_points=4). Para más puntos,
    // se requeriría un buffer más grande o escribir en el archivo por segmentos.
    static char all_points_buffer[256]; // Suficiente para el ejemplo de 4 puntos y un margen
    int current_buffer_pos = 0; // Posición actual en el buffer
    all_points_buffer[0] = '\0'; // Inicializa el buffer como una cadena vacía

    // --- 1. Abrir/Crear el archivo en modo escritura (FA_WRITE) ---
    // FA_CREATE_ALWAYS: Crea un archivo nuevo. Si ya existe, lo sobrescribe.
    fr_open = f_open(&fil, filename, FA_CREATE_ALWAYS | FA_WRITE);
    if (fr_open != FR_OK) {
        printf("Error: No se pudo abrir/crear el archivo '%s'. Codigo FatFs: %d\r\n", filename, fr_open);
        return fr_open; // Retorna directamente si la apertura falla, no hay archivo que cerrar.
    }

    // --- 2. Generar puntos y acumular en el buffer ---
    printf("Generando %d puntos sinusoidales en el buffer....\r\n", num_points);
    char temp_point_buffer[30]; // Buffer temporal para cada punto individual

    for (int i = 0; i < num_points; ++i) {
        double t = (double)i * duration / (double)(num_points > 1 ? num_points - 1 : 1);
        double value = amplitude * sin(2.0 * M_PI * frequency * t);

        // Formatea el valor y agrégalo al buffer temporal
        int len = snprintf(temp_point_buffer, sizeof(temp_point_buffer), "%.4f", value);

        // Calcula el espacio requerido en el buffer principal para el valor + coma potencial + terminador nulo
        int required_space = len + (i < num_points - 1 ? 1 : 0) + 1;

        // Verifica si añadir esto desbordará el buffer
        if (current_buffer_pos + required_space > sizeof(all_points_buffer)) {
            printf("Error: Buffer principal insuficiente en generate_sine_to_csv. Reduzca num_points o aumente el buffer.\r\n");
            final_res = FR_DISK_ERR; // O otro error apropiado
            goto cleanup_sine; // Salta a la limpieza
        }

        // Añade el valor formateado al buffer principal usando snprintf para seguridad
        current_buffer_pos += snprintf(&all_points_buffer[current_buffer_pos], sizeof(all_points_buffer) - current_buffer_pos, "%s", temp_point_buffer);

        // Añade una coma si no es el último punto
        if (i < num_points - 1) {
            current_buffer_pos += snprintf(&all_points_buffer[current_buffer_pos], sizeof(all_points_buffer) - current_buffer_pos, ",");
        }
    }
    // Añade un salto de línea al final de la fila de puntos
    if (current_buffer_pos + 1 > sizeof(all_points_buffer)) { // +1 para el salto de línea
        printf("Error: Buffer principal insuficiente para el salto de linea en generate_sine_to_csv.\r\n");
        final_res = FR_DISK_ERR;
        goto cleanup_sine;
    }
    current_buffer_pos += snprintf(&all_points_buffer[current_buffer_pos], sizeof(all_points_buffer) - current_buffer_pos, "\n");


    // --- 3. Escribe el buffer completo en el archivo ---
    printf("Escribiendo todos los puntos en el archivo....\r\n");

    fr_write_block = f_write(&fil, all_points_buffer, current_buffer_pos, &bytes_written);
    if (fr_write_block != FR_OK || bytes_written != current_buffer_pos) {
        printf("Error: No se pudieron escribir todos los puntos en '%s'. Codigo FatFs: %d\r\n", filename, fr_write_block);
        final_res = fr_write_block;
        goto cleanup_sine;
    }

    // --- 4. Escribe la segunda línea en el mismo archivo ---
    char second_line_data[] = "Datos adicionales del experimento.\n";
    fr_write_block = f_write(&fil, second_line_data, strlen(second_line_data), &bytes_written);
    if (fr_write_block != FR_OK || bytes_written < strlen(second_line_data)) {
        printf("Error: No se pudo escribir la segunda línea en '%s'. Codigo FatFs: %d\r\n", filename, fr_write_block);
        final_res = fr_write_block;
        goto cleanup_sine;
    }

cleanup_sine: // Etiqueta para la limpieza
    // --- 5. Cierra el archivo ---
    fr_close = f_close(&fil);
    if (fr_close != FR_OK) {
        printf("Error: No se pudo cerrar el archivo '%s'. Codigo FatFs: %d\r\r\n", filename, fr_close);
        if (final_res == FR_OK) { // Solo sobrescribe final_res si no hubo otro error
            final_res = fr_close;
        }
    }

    if (final_res == FR_OK) {
        printf("Datos sinusoidales (fila única) y línea adicional guardados exitosamente en '%s'.\r\r\n", filename);
    }
    return final_res;
}

/**
  * @brief Escribe los valores de un arreglo de magnitudes en un archivo CSV en la SD.
  * Formatea cada flotante y escribe en el archivo en bloques de 512 bytes.
  * El modo de apertura (crear o añadir) es controlado por el parámetro is_new_file.
  * @param filename Nombre del CSV en la SD (ej: "0:/DATA/magnitudes.csv")
  * @param magnitudes_array Puntero al arreglo de flotantes con las magnitudes.
  * @param num_magnitudes Número de elementos en el arreglo magnitudes_array.
  * @param is_new_file Booleano. Si es true, abre en FA_CREATE_ALWAYS. Si es false, abre en FA_OPEN_APPEND.
  * @retval FRESULT Código de resultado de la operación FatFs.
  */
FRESULT write_magnitudes_to_sd(const char* filename, float32_t* magnitudes_array, uint16_t num_magnitudes, bool is_new_file) {
    FIL fil;
    FRESULT res; // Consolidar variables de resultado
    UINT bytes_written;

    char write_buffer[512 + 1]; // Buffer para acumular datos formateados antes de escribir. +1 para el terminador nulo.
    int current_buffer_pos = 0; // Posición actual de escritura en el buffer.
    write_buffer[0] = '\0'; // ¡IMPORTANTE!: Inicializa el buffer como una cadena vacía al inicio.

    // Determina el modo de apertura basado en is_new_file
    BYTE open_mode = FA_WRITE | (is_new_file ? FA_CREATE_ALWAYS : FA_OPEN_APPEND);

#ifdef comments
    printf("Attempting to open file '%s' with mode %s....\r\n", filename, is_new_file ? "CREATE_ALWAYS" : "APPEND"); // Diagnóstico
#endif
    res = f_open(&fil, filename, open_mode);
    if (res != FR_OK) {
        printf("Error: f_open failed for '%s'. FatFs Code: %d\r\n", filename, res); // Error más específico
        return res; // Retorna directamente si la apertura falla, no hay archivo que cerrar.
    }
#ifdef comments
    printf("File '%s' opened successfully (f_open result: %d)....\r\n", filename, res); // Diagnóstico
#endif
    // Itera sobre las magnitudes, formatea y acumula en el buffer.
    for (uint16_t i = 0; i < num_magnitudes; ++i) {
        char temp_val_str[20]; // Buffer temporal para un valor float formateado.
        int chars_formatted;

        chars_formatted = snprintf(temp_val_str, sizeof(temp_val_str), "%.0f", magnitudes_array[i]);

        // Calcula el espacio requerido en el write_buffer para el valor actual y una coma (si es necesaria).
        int required_space = strlen(temp_val_str) + (i < num_magnitudes - 1 ? 1 : 0);

        // Si añadir este valor excede el límite del bloque de escritura (512 bytes - margen),
        // escribe el contenido actual del buffer al archivo.
        if (current_buffer_pos + required_space >= sizeof(write_buffer) - 40) { // Margen de 40 para seguridad extra
            res = f_write(&fil, write_buffer, current_buffer_pos, &bytes_written);
            if (res != FR_OK || bytes_written != current_buffer_pos) {
                printf("Error writing block (%d bytes) to file '%s'. FatFs Code: %d\r\n", current_buffer_pos, filename, res); // Diagnóstico
                goto cleanup; // Salta a la limpieza para asegurar que el archivo se cierre.
            }
            current_buffer_pos = 0; // Reinicia la posición del buffer.
            write_buffer[0] = '\0'; // Limpia el buffer para el siguiente bloque.
        }

        // Añade el valor formateado al buffer de escritura usando snprintf para seguridad.
        current_buffer_pos += snprintf(&write_buffer[current_buffer_pos], sizeof(write_buffer) - current_buffer_pos, "%s", temp_val_str);

        // Añade una coma si no es el último valor de todo el arreglo de magnitudes.
        if (i < num_magnitudes - 1) {
            current_buffer_pos += snprintf(&write_buffer[current_buffer_pos], sizeof(write_buffer) - current_buffer_pos, ",");
        }
    }

    // Después de procesar todos los valores, escribe cualquier dato restante en el buffer.
    // Luego, añade un salto de línea al final de esta "fila" de magnitudes para el CSV.
    if (current_buffer_pos > 0) {
        current_buffer_pos += snprintf(&write_buffer[current_buffer_pos], sizeof(write_buffer) - current_buffer_pos, "\n");

        res = f_write(&fil, write_buffer, current_buffer_pos, &bytes_written);
        if (res != FR_OK || bytes_written != current_buffer_pos) {
            printf("Error writing final block (%d bytes) to file '%s'. FatFs Code: %d\r\n", current_buffer_pos, filename, res); // Diagnóstico
            // No hay necesidad de goto aquí, naturalmente caerá en la limpieza
        }
    }

cleanup: // Etiqueta para la limpieza
    // Intenta sincronizar los datos del archivo con el disco antes de cerrar (puede ayudar con la consistencia).
    FRESULT sync_res = f_sync(&fil);
    if (sync_res != FR_OK) {
        printf("Warning: f_sync failed for file '%s'. FatFs Code: %d\r\n", filename, sync_res); // Diagnóstico
        if (res == FR_OK) { // Si no ocurrió ningún otro error, este es el problema principal
            res = sync_res;
        }
    }

    FRESULT close_res = f_close(&fil); // Cierra el archivo.
    if (close_res != FR_OK) {
        printf("Error: Could not close file '%s'. FatFs Code: %d\r\r\n", filename, close_res);
        if (res == FR_OK) { // Solo sobrescribe el resultado final si no hubo otro error.
            res = close_res;
        }
    }

    if (res == FR_OK) {
#ifdef comments
        printf("Magnitude data successfully saved to '%s'.\r\r\n", filename);
#endif
    }
    return res;
}

// --- END NEW FUNCTION ---

#endif
/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
